<?php

Создаем класс со свойствами плагинов (называем по имени плагина с большой буквы)

namespace core\base\settings;

class ShopSettings
{
    
    static private $_instance;

    private $templateArr = [
        'text' => ['name', 'phone', 'address', 'price', 'short'],
        'textarea' => ['content', 'keywords', 'goods_content']
    ];
}
 Но плагин - система расширений системы, поэтому расширяем основные настройки 
 Наследованием не получится, потому что основые свойства (routes) имеют private
 Если основные настройки сделать protected, то доп массивы, которые будут наследоваться
 ($templateArr) придется переписывать и дополнять 
 В итоге необходимо "склеивать" эти массивы у классов основных настроек и класса шаблона

 При создании класса расширения в паттерне singleton после первого создания класса неоьходимо
 объединить настройки (свойства) расширения с основными настройками (свойствами), для этого

 подключаем пространство имен основных настроек 

 namespace core\base\settings\Settings;

 И модернизируем функцию создания объекта класса расширешний 
 
 static public function instance()
    {
        if(self::$_instance instanceof self){
            return self::$_instance;
        }

        return self::$_instance = new self;
        При создании объекта класса настроек расширения мы должны объединить свойства с помощью
        методоа класса Settings
        Создаем переменную private $baseSettings в которую поместим объект класса Settings
        далее, обращаясь к ней, и далее к методу cluePropeties класса Settings объединяем настройки
        
        
        self::$_instance->$baseSettings = Settings::$instance();
        $basePropeties = self::$_instance->$baseSettings->cluePropeties(get_class());
    }

    Метод cluePropeties должен брать 2 массива (настройки - основной и расширение)
    и склеивать их
    public function cluePropteties($class)
    {

        $basePropeties = [];

        foreach($this as $name => $item){
            $property = $class::get($name);
            
            if(is_array($property) && is_array($item)){ проверяем, что данные - массивы, далее их нужно склеить
                функции array_merge_recursive() не подходит, т.к. она при однаковых ключах элемента создает массив с именем ключа
                и добавляет туда оба элемента, другая функция array_replace_recursive() тоже не подходит, она 
                при слейке массивов она перезаписала ключи массивов, вместо дополнения (arr1[0] перезаписала arr2[0] и тд)
                Нам необходимо: при нумерованном массиве - строки клеить, при ассоциативном - заменять (при переобъявлении),
                и дополнять, если таких ключей нет
                 $basePropeties['name'] = функция сортировки(подаем $this->$name(сюда попали все свойства класса), $propety(массив со
                 свойствами класса, который запрашивает метод))
                
            }
        }
        exit();
    }

    Функция склеивания:

    public function arrayMergeRecursive()
    {

        $arrays = func_get_args() - мы можем вытащить переменные из памяти (!!! они подавались аргументами, по
        месту вызова, но мы не работаем с ними напрямую, а сразу оба этой функцией) и поместить их в $arrays

        Далее нужно определить основной массив (он пришел первым), с которым будем клеить остальные

        Он будет первым, так что выдергиваем его ф-ей array_shift(), которая после этого
        удаляем этот элемент из массива

        $base = array_shift($arrays); сейчас в массиве arrays - 1 элемент

        Далее циклом проходим $arrays и забираем оставшиеся массивы (там сейчас массив $property)
         foreach($arrays as $array){
             далее собираем все данные из этого же массива (там только $property, он в нулевой ячейке)
             foreach($array as $key -> $value){
                 Проверяем, что внутри массива, который получили с цикла и внутри первого массива ($base['key'])
                 с таким же именем лежат массивы
                 if(is_array($value) && is_array($base['key'])){
                     вызываем рекурсивно эту же функцию, т.к. склеить нужно именно значения, а тут массивы
                     $base['key'] = $this->arrayMergeRecursive($base[$key], $value)

                 }

                 В else попадут уже новые переменные $base и $arrays(определенные в своей итерации,
                  они каждый раз заного переопределяются)

                  Проверяем, какой тип массива (нумерованные ключи или нет)
                    if(is_int($key)){
                        проверяем, есть ли такое значение в массиве (нам его надо добавить, если его нет)
                        if(in_array($value, $base)) array_push($base, $value)
                        continue;- означает, что выполнится условие выше или нет -> мы должны перейти на следующую
                        итерацию цикла foreach и поле ниже уже не выполнится ( $base['key'] = $value;)
                    }
                    Если ассоциативный - переопределяем значение по ключу
                    $base['key'] = $value;

         }
         И возвращаем $base

         return $base;

         Также добавляем continue в cluePropteties в цикле foreach после проверки на массивы

         Если в $propety придет null (сюда приходит значение свойства класса,
          (функции get) которого надо слить с главным)), то нужно вернуть это значение
          из главного класса (Settings) if(!$property) $basePropeties[$name] = $this->$name; ($name определено в цикле foreach)

         Но доступа к свойствам у объекта класса нет

         Для добавления свойств у объекта создаем функцию 
         protected function setProperty($properties){
            if($properties){
                foreach ($properties as $name => $property){
                    $this->$name = $property;
                }
            }
        }

        и вызываем ее у $_instance, передавая $basePropeties(где лежат все склееные св-ва)
        аргументом.
                
    }


