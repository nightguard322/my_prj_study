<?php


//1.Переделаем логику RouteController:

    //1. После проверки наличия маршрутов (routes)
    //Мы определяем $url = explode("/", substr($adress_str, strlen( PATH ))); - рвем строчку в адресной
    // строке по /, в самой адресной строке выбираем кусок подстроки, начинающийся с PATH
    // 2. Проверяем на наличие первого эл-та массива и наличие в нем на первом месте значения алиаса админки
    if($url[0] && $url[0] === $this->routes['admin']['alias']){
        // тут админка, поэтому первый элемент массива можно убрать
        array_shift($url);
        // далее проверяем, не плагин ли это
        if($url[0] && is_dir($_SERVER['DOCUMENT_ROOT'] . PATH . $this->routes['plugins']['path'])){
        // и т. д. 
        echo 'мы в плагинах';
        }
    } 
    
    //2. Далее, при запуске метода RouteController::getInstance()->route() он должен подключать другие методы,
    // которые будут являться контроллерами(отвечают за формирование набора параметров для модели для формирования данных
    // Route должен находится в классе, который будут наследовать другие методы

    // Создаем базовый класс, от которого будут наследоваться остальные классы с маршрутами
            // namespace core\base\controller;

            // abstract class BaseController
            // {
                
            // }
    // Но он не будет делать конечных действий, поэтому он будет абстрактным
                
    // 3. RouteController должен теперь наследоваться от BaseController
    // Т.к.    protected $controller;
    // protected $inputMethod;
    // protected $outputMethod;
    // protected $parameters; должны быть доступны у базового класса -> переносим их в BaseController;

    // 4. Описываем основной метод route

    // public function route(); - public потому, что обращаться к этому методу мы будем через ссылку на 
    // объект класса (RouteController::getInstance()->route(), а объект может обращаться только к public методам)
    $controller = str_replace('/', '\\', $this->controller); // - сюда попало имя класса контроллера, к которому переходит
    // управление, замена для того, чтобы через пространство имен можно было к нему обратиться
    
    //Для исключения проблем :
    // Надо проверить на существование файла, на ошибку в имени alias контроллера и на то, что класс в файле правильно
    // описан, а также наследован ли базовый класс (не будет главных методов), все это необходимо логгировать,
    
    // для всего этого применим встроенный в php класс reflection - он позволяет получить доступ к инфе 
    //  классах, свойствах, методах, абстрактный ли класс, защищенный или публичный метод

    // Будем использовать класс расширения reflection - ReflectionMethod (RM)

            //     1. В переменную сохраним объект класса RM - $object = new \ReflectionMethod(1 пар-р:Имя класса в строковом
            // виде или объект класса,2-й пар-р: имя метода, который ищем в этом классе);
            $object = new \ReflectionMethod($controller, 'request');
            // Когда создается объект RM он уже осущ-ет поиск метода request в классе $controller и далее мы даже
            // можем вызвать метод request - с помощью метода invoke(объект класса, у которого надо вызывать метод,
            // который указан в конструкторе, массив аргументов - $args)

            $args = [
                'parameters' => $this->$parameters,
                'inputMethod' => $this->inputMethod,
                'outputMethod' => $this->outputMethod
            ];  //с помощью него мы передадим созданному объекту RM св-ва класса $controller - protected $inputMethod;
            // protected $outputMethod; protected $parameters, они доступны только классу $controller

            $object->invoke(new $controller, $args); //эта запись вызовет метод request, который заполнит массив с параметрами
            // и ...
            // далее создадим метод request

            // Нам необходимо обезопасится от ошибок - провести обработку исключений
            try{
                $object = new \ReflectionMethod($controller, 'request');// если не создастся объект 
                // - будет исключение
                $args = [
                    'parameters' => $this->$parameters, //если 
                    'inputMethod' => $this->inputMethod,
                    'outputMethod' => $this->outputMethod
                ];
                $object->invoke(new $controller, $args);//если нельзя будет вызвать метод request и пере
                //дать аргументы => исключения
            }
            catch(\ReflectionException $e){
                 // выбросится дефолтное исключение класса RM, если: не будет класса с таким именем,
                //  не будет такого метода
                throw new RouteException($e); //генерируем (посылаем) исключение с такой же ошибкой,
                //что выдал RM выше (где то висит его перехватчик (RouteException) и ждет его
                //без разницы - тут вызовем или в другом месте)
            }

            // Далее создаем метод request:

            public function request($args){
                $this->parameters = $args['parameters'];  //Принимаем параметры чтобы работать с методами класса,
                //объект которого создает RM
                //далее выводим inputMethod и outputMethod в переменные, чтобы потом вызвать эти методы
                $inputData = $args['inputData']; //имя метода, который будет формировать параметры запроса для
                // модели, работающей с бд, обрабатывать полученные данные от модели
                $outputData = $args['outputData'];//решать вопрос с подключением вида

                // Далее вызываем метод, который в качестве строки находится в inputData, далее вызываем
                // метод outputData и выводим наши данные

                $this->$inputData();
                //далее вызываем выходной метод, который соберет шаблон (из данных, которые вернул inputdata)
                //данные вернем в переменную $page - страница header/content/sidebar/footer и тд

                protected $page;

                $this->page = outputData(); //- готовая страница, собранная из переменных, собранный шаблон

                // Создадим свойство для хранения ошибок
                protected $errors; // ошибки, которые нужно залогировать при построении шаблона

                // далее проверяем ошибки:
                if($this->errors){
                    $this->writeLog();
                }
                $this->getPage(); //метод сбора страницы


                protected function getPage(){
                    exit($this->page); //отображение страницы в браузер
                }

                protected function render($path = '', $parameters = [] ){
                //$path = '' - путь, по которому искать шаблон
                    //$parameters = [] - массив параметров, который в этот шаблон нужно передать){
                   
                //    Необходимо указать, что если не передан путь к шаблону, должен вызываться шаблон с именем 
                //    контроллера (IndexController - шаблон - Index)
                extract($parameters);
                 // Далее необходимо разобрать массив ф-ей extract - она вытаскивает ключ - и делает переменную
                    // с таким же именем, а значение - подставляет в значение переменной
                if(!$path){
                    $path = TEMPLATE . explode('controller', strtolover(new \ReflectionClass($this))->getShortName)[0]
                    //Необходимо вернуть имя класса без слова controller с маленькой буквы (по правилам наименования шаблонов,
                    // для этого через reflection получаем имя класса с маленькой буквы и разбиваем его по слову controller,
                    // после чего из полученного массива берем 1ый элемент(существует только он))
                }
                   //Далее необходимо поместить данные вывода в шаблон в буфер
                   ob_start(); //открываем буфер обмена

                   if(!@include_once($path . '.php')){ //пробует открыть шаблон, который лежит по пути - шаблоны/название к-ра
                    // и кидает в буфер инфомацию из него
                       throw new RouteException('Отсутсвует шаблон - ' . $path);
                   }
                        return ob_get_clean();


                }

            }