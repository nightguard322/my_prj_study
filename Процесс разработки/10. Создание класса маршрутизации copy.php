<?php

    Цель - создать метод __construct у RouteController

    RouteController - точка входа в системы контроллеров
    Этот и другие классы контроллеров будут наследовать один базовый класс, который будет выбирать
    (заниматься подключением других классов, будет распределять каким наследникам что делать)

    создаем свойства класса RouteController

    protected $routes; - свойство маршрутов

    Далее свойства для родительского класса

    protected $controller;
    protected $inputMethod; свойство, в котором хранится метод, собирающий данные из будет
    protected $outputMethod; св-во, в котором хранится имя метода, отвечающего за подключение видов (views)
    protected $parameters;

    Что делает RouteController - в адресной строке может быть имяДомена/catalog/phone, RC должен разобрать 
    адресную строку, определить по какому принципу исп-ть /catalog/, параметр /phone,
    
    1. Получаем адресную строку
        $adress_str = $_SERVER['REQUEST_URI']; 
        При получении из корня домена - получаем "/"
        А т.к. catalog и catalog/ у поисковых роботов - разные страницы, "/" в конце надо убирать

        if(strrpos($adress_str, '/')) === strlen($adress_str) - 1 && strrpos($adress_str, '/')) !== 0)
        strrpos - последнее вхождение подстроки в строку
        strlen($adress_str) - длина строки, но это массив, нумерация с 0, а длина строки с 1
        И необходимо исключить корень сайта, иначе будет вечный редирект, т.к. сервер постоянно
         подставляет этот символ
        , то перенаправляем на страницу без "/"
            $this->redirect(rtrim($address_str ), 301);  rtrim отрежет указанные символы, также отправляем код
            ответа сервера 301 в методе redirect, который опишем возже
    
    2.  
        $path = substr($_SERVER['PHP_SELF'], 0, strpos($_SERVER['PHP_SELF']), 'index.php') 
        - путь к корневому каталогу с index.php

        Далее проверяем, совпадает ли он с константой настройки PATH, если нет - ничего не загрузится
        Сделано для проверки корректных настроек при переносе на хостинг (по сути, если указаны неверные пути
        нет смысла нагружать сервер)
        if($path == PATH){

        }else{
            try{ 
                throw new \Exeption('Некорректная директория сайта'); выбросим исключение базового класса Exeption
            }
            catch(\Exeption $e){ получаем объект класса исключения $e
                exit($e->getMessage()); методом получаем сообщение исключения
            }
        }

        Если условие совпало: 

        if($path == PATH){

            $this->$routes = Settings::get('routes'); Получаем маршруты в свойство routes класса RC из настроек методом get
            класса Settings::

            if(!this->routes) try{ если маршрутов нет - кидаем exceptions
                    throw new RouteExeption('Сайт находится на техническом обслуживании');
                    exit();
            }
            далее проверяем, не админский ли контроллер сейчас нужно подключать
            
            if(strpos($address_str, $this->routes['admin']['alias'] ) === strlen(PATH)
            //Если до начала значения ключа alias в массиве admin в строке 
            //$address_str кол-во символов = длине PATH
            далее разбираем админпанель
            }else{
                $url = explode('/', substr($address_str, strlen(PATH))); //разбиваем строку в адресной строке без
                //точки входа (PATH)
                // Проверяем переменную в настройках на необходимость читаемых адресов hrUrl
                $hrUrl = $this->routes['user']['hrUrl'];

                // далее определяем, откуда подключать контроллер

                $this->controller = $this->routes['user']['path'];// - путь к папке контроллера, название прклеим потом

                // Т.к. маршрута пока тут нет => необходим метод, который создаст маршрут, относительно того, 
                // админская или польз-кая часть, путь это или нет и тд

                $route = 'user';

            }
            $this->createRoute($route, $url)  //создаем метод, который создаст маршрут, он принимает 
            // маршрут, который нужно создать и массив ссылок, из которых он соберет маршрут


            private function createRoute($var, $arr){  //метод создания маршрутов, на входе маршрут и данные с адресной строки
                //после explode
                $route = []; //формируем массив 

                if(!empty($this->arr[0])) //если первое значение не пустое (сработало условие,что мы в $url берем данные после PATH)
                    if($this->$routes[$var]['routes'][$arr[0]]){ //если существует значение в св-ве routes (::settings) с ключом 
                        //   var routes (admin,user) и первое значение из переданного массива (с таким же названием) - alias (н-р catalog)
                       // , записанный 'routes' =>  
                                                    // [    
                                                    //     'catalog' => 'site'
                                                    // ]
                        $route = $this->$routes[$var]['routes'][$arr[0]];
                    }
            }

           // маршруты ('catalog') будут вида:

            // 'user' => [
            //     'routes' => [
            //         'catalog' => 'site/input/output'; //где site - контроллер, который подключить
                    //input - метод сборки данных, output - метод отдачи данных. Если какого то метода нет = дефолтный
                ]
            ]

            // далее добавляем в к переменной с путем к контроллеру его имя (с большой буквы, т.к. это будет путь к классу):

            $this->$controller .= ucfirst($route[0].'Controller');
                    else (если маршрут не описан){
                        $this->$controller .= ucfirst($arr[0].'Controller');
                    }
            //Если нет массива $arr 

            else{
                $route = $this->routes['default']['controller'];
            }

            // Далее определяем подключенные методы
            // Добавляем входной метод (=): если $route[1] (не пустой), то его и добавим, иначе дефолтный
            $this->inputMethod = $route[1] ? $route[1] : $this->routes['default']['inputMethod'];
            $this->outputMethod = $route[2] ? $route[2] : $this->routes['default']['outputMethod'];

            return;